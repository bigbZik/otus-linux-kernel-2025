# Задание: Модуль ядра Linux со стеком на основе связных списков

## Цель работы

Разработать модуль ядра Linux, который реализует структуру данных **стек (Stack)** с использованием встроенных механизмов связных списков ядра (`list.h`). Взаимодействие с модулем должно осуществляться через интерфейс **sysfs**.

Задание развивает навыки работы с:
- Структурами данных в ядре Linux
- Встроенными макросами и функциями для работы со связными списками
- Системой управления памятью в ядре
- Интерфейсом sysfs для взаимодействия с модулем

---

## Требования к реализации

### 1. Структура данных стека

#### 1.1 Основная структура стека
Необходимо создать структуру для представления стека:

```c
struct stack {
    struct list_head elements;      /* Голова связного списка */
    int size;                        /* Текущее количество элементов */
};
```

#### 1.2 Структура элемента стека
Каждый элемент стека должен содержать:

```c
struct stack_entry {
    struct list_head list;          /* Узел связного списка */
    int data;                       /* Данные (целое число) */
};
```

### 2. Операции над стеком

Реализовать следующие функции в файле `lib/stack_ops.c`:

| Функция | Описание | Возвращаемое значение |
|---------|---------|----------------------|
| `stack_init()` | Инициализация стека | void |
| `stack_push(int value)` | Добавить элемент на вершину стека | int (0 - успех, -1 - ошибка) |
| `stack_pop()` | Удалить и вернуть элемент с вершины | int (значение или код ошибки) |
| `stack_peek()` | Получить значение с вершины без удаления | int (значение или код ошибки) |
| `stack_is_empty()` | Проверить пустоту стека | int (1 - пусто, 0 - не пусто) |
| `stack_size()` | Получить размер стека | int (количество элементов) |
| `stack_clear()` | Очистить стек | void |

### 3. Интерфейс sysfs

Модуль должен создать атрибуты sysfs в папке `/sys/kernel/kernel_stack/` с следующим функционалом:

| Атрибут | Режим | Операция | Формат |
|---------|-------|---------|--------|
| `push` | write | Добавить элемент | Целое число (например: `echo 42 > push`) |
| `pop` | read | Получить и удалить элемент | Целое число из стека или сообщение об ошибке |
| `peek` | read | Получить значение вершины | Целое число из стека или сообщение об ошибке |
| `size` | read | Получить размер стека | Текущее количество элементов |
| `is_empty` | read | Проверить пустоту | "1" (пусто) или "0" (не пусто) |
| `clear` | write | Очистить стек | Любое значение для запуска очистки |

#### Указания к реализации sysfs интерфейса

Используйте макросы для создания атрибутов sysfs. Все реализации атрибутов должны находиться в файле `src/sysfs.c`.

Доступные макросы:
- [DEVICE_ATTR_RW](https://elixir.bootlin.com/linux/v6.1.130/C/ident/DEVICE_ATTR_RW) - атрибут для чтения и записи
- [DEVICE_ATTR_RO](https://elixir.bootlin.com/linux/v6.1.130/C/ident/DEVICE_ATTR_RO) - атрибут только для чтения
- [DEVICE_ATTR_WO](https://elixir.bootlin.com/linux/v6.1.130/C/ident/DEVICE_ATTR_WO) - атрибут только для записи

Примеры использования этих макросов можно найти на [Elixir Bootlin](https://elixir.bootlin.com/linux/v6.1.130/C/ident/DEVICE_ATTR_RW).

### 4. Требования к безопасности

- ✅ Корректно обрабатывать ошибки выделения памяти (`kmalloc`)
- ✅ Проверять граничные условия (операции над пустым стеком)
- ✅ Освобождать память при удалении модуля

### 5. Обработка ошибок

Определить и документировать коды возврата:

```c
#define STACK_OK          0      /* Операция успешна */
#define STACK_EMPTY      -1      /* Стек пуст */
#define STACK_NOMEM      -2      /* Нет памяти */
#define STACK_INVALID    -3      /* Неверный параметр */
```

---

## Структура проекта

```
kernel_stack_module/
├── Makefile                 # Главный файл сборки
├── Kbuild                   # Конфигурация сборки модуля
├── src/
│   ├── main.c               # Основной код модуля
│   └── sysfs.c              # Реализация sysfs интерфейса
├── lib/
│   ├── stack.c              # Реализация структуры данных стека
│   ├── stack_ops.c          # Реализация операций со стеком
│   └── inc/
│       ├── stack.h          # Заголовок для функций стека
│       └── stack_ops.h      # Заголовок для операций стека (опционально)
└── inc/
    └── kernel_stack.h       # Заголовок для модуля
```

Модуль должен иметь название `kernel_stack.ko` при сборке.

---

## Пример использования после загрузки модуля

```bash
# Загрузить модуль
sudo insmod kernel_stack.ko

# Добавить элементы
echo 10 > /sys/kernel/kernel_stack/push
echo 20 > /sys/kernel/kernel_stack/push
echo 30 > /sys/kernel/kernel_stack/push

# Проверить размер
cat /sys/kernel/kernel_stack/size
# Вывод: 3

# Получить вершину без удаления
cat /sys/kernel/kernel_stack/peek
# Вывод: 30

# Удалить и получить элемент
cat /sys/kernel/kernel_stack/pop
# Вывод: 30

# Проверить новый размер
cat /sys/kernel/kernel_stack/size
# Вывод: 2

# Проверить пустоту
cat /sys/kernel/kernel_stack/is_empty
# Вывод: 0

# Очистить стек
echo 1 > /sys/kernel/kernel_stack/clear

# Выгрузить модуль
sudo rmmod kernel_stack
```

---

## Формат сдачи

Сдавайте архив со следующей структурой:

```
студент_фамилия_kernel_stack.tar.gz
├── Makefile
├── Kbuild
├── src/
│   ├── main.c
│   └── sysfs.c
├── lib/
│   ├── stack.c
│   ├── stack_ops.c
│   └── inc/
│       ├── stack.h
│       └── stack_ops.h
└── inc/
    └── kernel_stack.h
```

---

**Удачи в разработке! Если есть вопросы, обратитесь на консультацию.**
